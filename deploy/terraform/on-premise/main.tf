# On-Premise Terraform Configuration for E2EE WebRTC Infrastructure
# For deployment on your own hardware or private cloud

terraform {
  required_version = ">= 1.0"

  # For on-premise, you might use local backend or private S3-compatible storage
  backend "local" {
    path = "terraform.tfstate"
  }
}

# Variables for on-premise deployment
variable "environment" {
  description = "Environment name"
  type        = string
  default     = "production"
}

variable "domain_name" {
  description = "Domain name for the services"
  type        = string
}

variable "turn_secret" {
  description = "TURN server shared secret"
  type        = string
  sensitive   = true
}

variable "signaling_hosts" {
  description = "List of signaling server hostnames/IPs"
  type        = list(string)
}

variable "turn_hosts" {
  description = "List of TURN server hostnames/IPs"
  type        = list(string)
}

variable "redis_host" {
  description = "Redis server hostname/IP"
  type        = string
}

variable "redis_password" {
  description = "Redis password"
  type        = string
  sensitive   = true
}

variable "ssh_private_key_path" {
  description = "Path to SSH private key for provisioning"
  type        = string
  default     = "~/.ssh/id_rsa"
}

variable "ssh_user" {
  description = "SSH user for provisioning"
  type        = string
  default     = "root"
}

# Local values
locals {
  common_tags = {
    Project     = "e2ee-webrtc"
    Environment = var.environment
    ManagedBy   = "terraform"
  }
}

# This configuration generates Ansible inventory and configuration files
# for on-premise deployment

# Generate Ansible inventory
resource "local_file" "ansible_inventory" {
  filename = "${path.module}/generated/inventory.yml"
  content = yamlencode({
    all = {
      vars = {
        ansible_user                = var.ssh_user
        ansible_ssh_private_key_file = var.ssh_private_key_path
        ansible_python_interpreter  = "/usr/bin/python3"
        environment                 = var.environment
        domain_name                 = var.domain_name
        redis_host                  = var.redis_host
        redis_password              = var.redis_password
        turn_secret                 = var.turn_secret
      }
      children = {
        signaling = {
          hosts = { for idx, host in var.signaling_hosts :
            "signaling-${idx + 1}" => {
              ansible_host = host
            }
          }
          vars = {
            role = "signaling"
          }
        }
        turn = {
          hosts = { for idx, host in var.turn_hosts :
            "turn-${idx + 1}" => {
              ansible_host = host
              public_ip    = host
            }
          }
          vars = {
            role = "turn"
          }
        }
        redis = {
          hosts = {
            "redis-1" = {
              ansible_host = var.redis_host
            }
          }
          vars = {
            role = "redis"
          }
        }
      }
    }
  })
}

# Generate environment configuration
resource "local_file" "env_config" {
  filename = "${path.module}/generated/.env"
  content  = <<-EOF
    # E2EE WebRTC Configuration
    # Generated by Terraform

    ENVIRONMENT=${var.environment}
    DOMAIN_NAME=${var.domain_name}

    # Redis
    REDIS_URL=redis://:${var.redis_password}@${var.redis_host}:6379

    # TURN
    TURN_SECRET=${var.turn_secret}
    TURN_SERVERS=${join(",", [for host in var.turn_hosts : "turn:${host}:3478"])}

    # Signaling
    SIGNALING_SERVERS=${join(",", [for host in var.signaling_hosts : "wss://${host}:443"])}
  EOF

  file_permission = "0600"
}

# Generate Docker Compose for on-premise
resource "local_file" "docker_compose" {
  filename = "${path.module}/generated/docker-compose.yml"
  content  = <<-EOF
    version: '3.8'

    services:
      signaling:
        image: ghcr.io/your-org/e2ee-signaling:latest
        ports:
          - "3001:3001"
        environment:
          - REDIS_URL=redis://:${var.redis_password}@${var.redis_host}:6379
          - NODE_ENV=${var.environment}
          - PORT=3001
        restart: unless-stopped
        deploy:
          replicas: ${length(var.signaling_hosts)}
        healthcheck:
          test: ["CMD", "curl", "-f", "http://localhost:3001/health"]
          interval: 30s
          timeout: 10s
          retries: 3

    networks:
      default:
        driver: bridge
  EOF
}

# Generate nginx configuration
resource "local_file" "nginx_config" {
  filename = "${path.module}/generated/nginx.conf"
  content  = <<-EOF
    # Nginx configuration for E2EE WebRTC
    # Place this in /etc/nginx/sites-available/

    upstream signaling {
        ${join("\n        ", [for host in var.signaling_hosts : "server ${host}:3001;"])}
        keepalive 32;
    }

    server {
        listen 80;
        server_name ${var.domain_name};
        return 301 https://$server_name$request_uri;
    }

    server {
        listen 443 ssl http2;
        server_name ${var.domain_name};

        ssl_certificate /etc/letsencrypt/live/${var.domain_name}/fullchain.pem;
        ssl_certificate_key /etc/letsencrypt/live/${var.domain_name}/privkey.pem;

        ssl_protocols TLSv1.2 TLSv1.3;
        ssl_ciphers ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256;
        ssl_prefer_server_ciphers off;

        # WebSocket support
        location / {
            proxy_pass http://signaling;
            proxy_http_version 1.1;
            proxy_set_header Upgrade $http_upgrade;
            proxy_set_header Connection "upgrade";
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;

            proxy_read_timeout 86400;
            proxy_send_timeout 86400;
        }

        # Health check endpoint
        location /health {
            proxy_pass http://signaling/health;
        }
    }
  EOF
}

# Generate deployment script
resource "local_file" "deploy_script" {
  filename        = "${path.module}/generated/deploy.sh"
  file_permission = "0755"
  content         = <<-EOF
    #!/bin/bash
    set -e

    echo "E2EE WebRTC On-Premise Deployment"
    echo "================================="

    # Check prerequisites
    command -v ansible >/dev/null 2>&1 || { echo "ansible is required but not installed."; exit 1; }

    # Run Ansible playbook
    ansible-playbook -i inventory.yml ../../ansible/playbooks/site.yml

    echo ""
    echo "Deployment complete!"
    echo ""
    echo "Signaling servers: ${join(", ", var.signaling_hosts)}"
    echo "TURN servers: ${join(", ", var.turn_hosts)}"
    echo "Redis server: ${var.redis_host}"
  EOF
}

# Outputs
output "signaling_servers" {
  description = "Signaling server endpoints"
  value       = [for host in var.signaling_hosts : "wss://${host}:443"]
}

output "turn_servers" {
  description = "TURN server endpoints"
  value       = [for host in var.turn_hosts : "turn:${host}:3478"]
}

output "stun_servers" {
  description = "STUN server endpoints"
  value       = [for host in var.turn_hosts : "stun:${host}:3478"]
}

output "deployment_instructions" {
  description = "Instructions for deploying"
  value       = <<-EOF
    To deploy:
    1. cd ${path.module}/generated
    2. ./deploy.sh

    Or manually:
    ansible-playbook -i generated/inventory.yml ../ansible/playbooks/site.yml
  EOF
}
